#Linux 进程管理

##C程序的存储空间布局

* 正文段: CPU执行的机器指令,只读的,可共享的(在存储器中只需一个副本).
* 初始化数据段: 存放明确赋初值的变量,如 `int max = 99;`
* 非初始化数据段: 存放未初始化的变量,内核将此段中数据初始化为0或空指针, 如`long sum[100];
* 栈: 保存局部变量,函数调用的返回地址和调用者环境信息.每次调用函数都会创建一个新的栈帧,保存当前函数调用的变量集.
* 堆: 进行动态存储分配,如malloc

逻辑布局由高地址到低地址依次:

栈->空闲空间用于扩充->堆->未初始化数据->初始化的数据->正文

##进程怎么表示?

1.在linux内核中,进程由一个相当大的`task_struct`结构体表示.

task_struct包含的内容:

* 执行的状态:(TASK_RUNNING,TASK_INTERRUPTIBLE,TASK_UNINTERRUPTIBLE,TASK_STOPPED>等)
* 堆栈
* 一组标志
* 父进程
* 优先级
* struct list_head tasks:链接任务列表,包含一个prev指针和一个next指针,指向前后两>个任务.
* 等等

2.进程标识符PID:总是唯一,可重用,当一个进程终止后,其PID就可以再次使用了.

##进程是怎么创建的?

* 执行一个程序,会导致新进程的创建
* 在程序内,调用`fork`或`exec`系统调用.

fork和exec都是调用内核的do_fork()函数来创建新进程

fork函数:

fork完父进程和子进程将分开并行执行
关于fork的理解,参考http://coolshell.cn/articles/7965.html

* 由fork创建出来的进程叫子进程
* fork被调用一次,会返回两次.返回给子进程0,返回给父进程的是子进程的PID.
* 失败时返回-1
* 子获得了父的数据空间,堆,栈的副本(不共享)
* 子和父共享正文段
* 子和父共享文件
* 子从父继承了整个进程的地址空间,包括:进程上下文,堆栈,内存信息,打开的文件描述符,优先级,进程组号等.


子进程与父进程的区别:

* fork的返回值不同
* 进程ID不同,父进程ID不同
* 附近城设置的文件锁不会被继承

vfork函数与fork函数:

* 都用于创建一个新进程
* 不同点1:vfork并不会将父进程的地址空间完全复制到子进程,而是父子共享地址空间,一个修改对另一个可见.不具有fork带来的独立性.
* 不同点2:vfork保证子进程前执行,在它调用exec或exit之后父进程才可能被执行.fork不提供保证.

##进程创建时内核做了什么?

* 在系统的物理内存中为新的进程分配新的task_struct结构体
* 为新进程的堆栈分配物理页
* 为新进程分配新的进程标识符

##进程终止

1.父进程先终止:

此时它的所有子进程(孤儿进程)都将父进程改变为init进程(PID=1)(由init进程领养).

2.子进程先终止:

子进程必须等到父进程捕获到它的终止状态才真正终止.否则将成为僵死进程.

内核为每个终止子进程保存了一些信息(PID,终止状态,进程使用CPU总量),此子的父进程将用这些信息做一些善后处理(释放它占有的资源).

僵死进程:一个进程已经终止,但是其父尚未对其进行善后处理.

防止僵死进程:调用fork两次
