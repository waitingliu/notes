#JMM-1

#串行编程时代

一段程序的执行永远是顺序的，所以不必担心语句执行的具体细节．这为编译器，CPU，存储器，提供了极大的操作灵活性．

#并发时代

需要处理的两个关键问题：
* 线程之间如何`通信`
* 线程之间如何`同步`

#线程之间通信机制有两种：共享内存和消息传递．Java并发采用的是共享内存，线程间通信总是隐式进行的，对程序员透明．#

* 一方面，Java线程间通信由JMM控制，由JMM决定一个线程的写入何时对另一个线程可见．
* 另一方面，并发时代，执行优化的实现变得更加复杂，如果不对多个线程并发访问进行`同步`控制，可能会造成结果的不一致．JMM被制定出来，提供语法规则，加以约束．

JMM 定义了`线程`和`内存`的抽象关系:

* 线程之间的共享变量：存储在主内存．
* 每个线程都有一个私有的本地内存，里面存放共享变量的副本

```
	线程A -> 本地内存A -> 主内存
	线程B -> 本地内存B -> 主内存
```

JMM确保在不同编译器，处理器上，通过禁止特定类型的重排序，为程序员提供一致的内存可见性保证．

* 原子性：保证得到的数据是初始化过的，或修改后的．(#不能保证是最新修改#)
* 可见性：线程对数据的修改对另一个线程可见．

JMM比较宽松，`如果...,就能保证...,但是不是一定要...`

#顺序一致性内存模型

是理想化的，理论的内存模型．

* 一个线程中的所有操作必须按照程序顺序来执行
* 每个操作都必须原子执行，且立即对所有线程可见

与之相比，JMM：

* 临界区内的代码可以重排序
* 基本思想是在不改变程序执行结果的前提下，尽可能的支持编译器和处理器的重排序优化



