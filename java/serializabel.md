#序列化&反序列化

##定义

* 序列化:将对象转换成二进制串
* 反序列化: 将序列化而成的二进制串转换成对象

二进制串:指的是存储在内存中的一块数据.在Java中指的是byte[]

##序列化协议的选择

每种序列化协议都有自己适合的应用场景.在系统设计过程中,需要考虑序列化需求的方方面面,综合对比各种序列化协议的特性,最终给出一个折衷的方案.

###通用性

* 是否支持跨平台,跨语言.
* 流行程度

###鲁棒性

* 采用成熟度高的
* 语言/平台的不公平性

###可读性

* XML/JSON

###性能

* 空间开销:如果序列化引入的额外开销过高,可能导致过大的网络压力,磁盘压力.
* 时间开销:复杂的序列化协议会导致解析时间长,可能会使序列化成为系统的瓶颈

###可扩展性

* 支持自动增加新的业务字段,而不影响老的服务.

###安全性

* 跨局域网访问时需要考虑
* 往往被限制为基于HTTP/HTTPS的80和443端口,所以需要兼容且成熟的HTTP传输层框架的支持.

##当下流行的序列化协议

###1.XML

优点:常用的序列化/反序列化协议,具有跨机器,跨语言的特点.可读性强,多用于配置文件.
缺点:序列化对象时,显得冗长而复杂.额外空间开销大

###2.JSON

优点:
* 人眼可读
* 更简洁
* 具备Javascript的先天支持性,广泛用于Web browser的应用场景.
* 解析速度快
* 松散的结构,具有良好的可扩展性

JSON应用场景:

* 公司之间传输数据量小,实时性要求低(秒级别)的服务.
* 基于Web browser的ajax请求
* 手机app与服务端的通讯

缺点:

* 没有统一可用的IDL,降低了对参与方的约束.只能采用文档方式进行约定.对于性能要求为ms级别的不建议使用


###3.Thrift

Thrift是Facebook开源的高性能,轻量级RPC服务框架.

优点:适用于高性能,分布式的RPC服务解决方案.
缺点:文档缺乏,使用基础少.序列化后不具有可读性.

###4.Protobuf

Google产生,仅仅支持Java,C++,Python三种语言.
是非常优秀的序列化协议,设计理念是纯粹的展现层协议

具有广泛的用户基础
空间开销小,解析性能高
非常适合对性能要求高的RPC调用.

###5.Avro

是Hadoop的子项目,支持两种序列化格式:JSON和Binary

解析性能高,序列化后的数据非常简洁,比较适合于高性能的序列化服务

##选型建议

以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：
1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。
2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。
3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。
4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。
5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。
6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。
7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。
8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。
9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
